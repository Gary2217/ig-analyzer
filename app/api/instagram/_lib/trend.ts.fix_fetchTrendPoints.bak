import { createAuthedClient, supabaseServer } from "@/lib/supabase/server"

export type TrendMetric = "reach" | "followers" | "impressions" | "accounts_engaged" | "total_interactions"

export const VALID_METRICS: TrendMetric[] = [
  "reach",
  "followers",
  "impressions",
  "accounts_engaged",
  "total_interactions",
]

export function clampDays(raw: string | null): number {
  const n = Number(raw)
  if (!Number.isFinite(n)) return 30
  const i = Math.floor(n)
  if (i < 7) return 7
  if (i > 365) return 365
  return i
}

export function utcDayStringFromMs(ms: number): string {
  const d = new Date(ms)
  const y = d.getUTCFullYear()
  const m = String(d.getUTCMonth() + 1).padStart(2, "0")
  const dd = String(d.getUTCDate()).padStart(2, "0")
  return `${y}-${m}-${dd}`
}

export type TrendPoint = { day: string; value: number }

export type ResolvedTenant = {
  ig_account_id: string
  rangeStart: string
  rangeEnd: string
  days: number
}

/** Resolves authed user + active IG account + date range. Returns null with an error string on failure. */
export async function resolveTenant(
  daysParam: string | null,
): Promise<{ ok: true; tenant: ResolvedTenant } | { ok: false; error: string; status: number }> {
  const authed = await createAuthedClient()
  const userRes = await authed.auth.getUser()
  const user = userRes?.data?.user ?? null
  if (!user?.id) {
    return { ok: false, error: "missing_auth", status: 401 }
  }

  const { data: activeAccount } = await authed
    .from("user_instagram_accounts")
    .select("id")
    .eq("user_id", user.id)
    .eq("is_active", true)
    .order("updated_at", { ascending: false })
    .limit(1)
    .maybeSingle()

  const ig_account_id =
    activeAccount && typeof (activeAccount as any).id === "string"
      ? String((activeAccount as any).id).trim()
      : ""
  if (!ig_account_id) {
    return { ok: false, error: "NO_ACTIVE_IG_ACCOUNT", status: 400 }
  }

  const days = clampDays(daysParam)
  const now = new Date()
  const endMs = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate(), 0, 0, 0, 0)
  const startMs = endMs - (days - 1) * 24 * 60 * 60 * 1000
  const rangeStart = utcDayStringFromMs(startMs)
  const rangeEnd = utcDayStringFromMs(endMs)

  return { ok: true, tenant: { ig_account_id, rangeStart, rangeEnd, days } }
}

/** Fetches trend points for a single metric from DB. */
export async function fetchTrendPoints(
  metric: TrendMetric,
  tenant: ResolvedTenant,
): Promise<{ ok: true; points: TrendPoint[] } | { ok: false; error: string; message: string }> {
  const { ig_account_id, rangeStart, rangeEnd } = tenant

  if (metric === "followers") {
    const r = await supabaseServer
  .from("account_daily_snapshot")
  .select("day," + col)
  .eq("user_id_text", ig_account_id as any)
  .gte("day", rangeStart)
  .lte("day", rangeEnd)
  .order("day", { ascending: true })

    if (r.error) {
      return { ok: false, error: "QUERY_FAILED", message: (r.error as any)?.message ?? String(r.error) }
    }

    const points = (Array.isArray(r.data) ? r.data : [])
      .map((row: any) => {
        const day = typeof row?.day === "string" ? String(row.day).slice(0, 10) : ""
        const v = typeof row?.followers_count === "number" ? row.followers_count : Number(row?.followers_count)
        if (!day || !Number.isFinite(v)) return null
        return { day, value: Math.floor(v) }
      })
      .filter(Boolean) as TrendPoint[]

    return { ok: true, points }
  }

  const col =
    metric === "reach"
      ? "reach"
      : metric === "impressions"
        ? "impressions"
        : metric === "accounts_engaged"
          ? "accounts_engaged"
          : "total_interactions"

  const r = await supabaseServer
    .from("account_daily_snapshot")
    .select("day," + col)
    .eq("ig_account_id", ig_account_id as any)
    .gte("day", rangeStart)
    .lte("day", rangeEnd)
    .order("day", { ascending: true })

  if (r.error) {
    return { ok: false, error: "QUERY_FAILED", message: (r.error as any)?.message ?? String(r.error) }
  }

  const points = (Array.isArray(r.data) ? r.data : [])
    .map((row: any) => {
      const day = typeof row?.day === "string" ? String(row.day).slice(0, 10) : ""
      const raw = row?.[col]
      const v = typeof raw === "number" ? raw : Number(raw)
      if (!day || !Number.isFinite(v)) return null
      return { day, value: Math.floor(v) }
    })
    .filter(Boolean) as TrendPoint[]

  return { ok: true, points }
}

